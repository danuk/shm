package Core::Identities;

use v5.14;
use parent 'Core::Base';
use Core::Base;
use File::Temp;
use Core::Utils qw(
    file_by_string
    read_file
    exec_local_file
);

sub table { return 'identities' };

sub structure {
    return {
        id => {
            type => 'number',
            key => 1,
            title => 'id ключа',
        },
        name => {
            type => 'text',
            required => 1,
            title => 'имя ключа',
        },
        private_key => {
            type => 'text',
            required => 1,
            title => 'приватный ключ',
        },
        public_key => {
            type => 'text',
            title => 'публичный ключ',
        },
        fingerprint => {
            type => 'text',
            required => 1,
            title => 'отпечаток ключа',
        },
    }
}

sub add {
    my $self = shift;
    my %args = (
        name => undef,
        private_key => undef,
        @_,
    );

    $args{fingerprint} ||= $self->make_fingerprint( file_by_string( $args{private_key} ) );

    unless ( $args{fingerprint} ) {
        logger->error("Can't create fingerprint.");
        return undef;
    }
    return $self->SUPER::add( %args );
}

sub make_fingerprint {
    my $self = shift;
    my $file = shift;

    my $result = exec_local_file(
        cmd => ['ssh-keygen', '-l', '-E', 'MD5', '-f', $file],
        timeout => 3,
    );

    if ( $result->{success} && $result->{output} ) {
        my $output = $result->{output};
        chomp $output;
        $output =~ s/^\d+\s//;
        return $output;
    }
    return undef;
}

sub private_key_file {
    my $self = shift;

    return file_by_string( $self->res->{private_key} );
}

sub generate_key_pair {
    my $self = shift;
    my %args = (
        type => 'ed25519',
        @_,
    );

    my %supported_types = (
        'rsa' => 1,
        'dsa' => 1,
        'ecdsa' => 1,
        'ed25519' => 1,
    );

    unless ( $supported_types{ $args{type} } ) {
        logger->error("Unsupported key type: $args{type}");
        return undef;
    }

    my $temp_dir = File::Temp::tempdir();
    my $file = sprintf('%s/ssh_key_%d_%d_%d', $temp_dir, $$, time(), int(rand(999999)));

    if ( -e $file || -e "$file.pub" ) {
        logger->error("Temporary SSH key files already exist: $file");
        return undef;
    }

    my $keygen_result = exec_local_file(
        cmd => ['ssh-keygen', '-t', $args{type}, '-E', 'MD5', '-N', '', '-C', 'Generated by SHM', '-f', $file],
        timeout => 3,
    );

    unless ( $keygen_result->{success} ) {
        logger->warning("Can't generate ssh key pair: " . ($keygen_result->{output} || $keygen_result->{error} || 'Unknown error'));
        logger->warning("Command failed with exit code: " . ($keygen_result->{exit_code} || 'unknown'));
        unlink $file, "$file.pub";
        return undef;
    }

    unless ( -f $file && -f "$file.pub" ) {
        logger->error("SSH key files were not created");
        unlink $file, "$file.pub";
        return undef;
    }

    my $private_key = read_file($file);
    my $public_key = read_file("$file.pub");

    unless ( $private_key && $public_key ) {
        logger->error("Can't read generated SSH key files");
        unlink $file, "$file.pub";
        return undef;
    }

    my $fingerprint = $self->make_fingerprint($file);
    unless ( $fingerprint ) {
        logger->error("Can't generate fingerprint for SSH key");
        return undef;
    }

    my $cleanup_result = unlink $file, "$file.pub";
    logger->debug("Cleaned up temporary SSH key files: $cleanup_result files removed");


    my %struct = (
        private_key => $private_key,
        public_key => $public_key,
        fingerprint => $fingerprint,
    );

    return \%struct;
}

sub list_for_api {
    my $self = shift;
    my %args = (
        @_,
    );

    my @arr = $self->SUPER::list_for_api( %args );
    delete $_->{private_key} for @arr;

    return @arr;
}

1;
